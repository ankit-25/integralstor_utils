import socket, re, fcntl , struct, os, shutil, time, netifaces
import pprint
from os import path
from integralstor_common import command


'''

  VALIDATION AND UTILITY FUNCTIONS

'''

def validate_netmask(mask):
  #Check the given netmask to see if its valid. True/False return
  valid = True
  try:
    nmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", mask)
    if nmatch:
      gr = nmatch.groups()
      if gr:
        for g in gr:
          bits =  bin(int(g))[2:].zfill(8)
          #print int(g), bits
          if int(g) != 0:
            m = re.match(r'(1+)(0*)$', bits)
            if not m:
              #print 'invalid component - %s'%bits
              valid = False
      else:
        valid = False
    else:
      valid = False
  except Exception, e:
    return False, "Error validating netmask : %s"%str(e)
  else:
    return valid, None


def _validate_ip_format(addr):
  # Check if the given address is a set of 4 numbers in dotted decimal
  ret = False
  try:
    test = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
    result = test.match(addr)
    if result:
      ret = True
    else:
      ret =  False
  except Exception, e:
    return False, "Error validating IP address format : %s"%str(e)
  else:
    return ret, None

def validate_ip(addr):
  # Check if the given address is a set of 4 numbers in dotted decimal AND in the 0-255 range
  ret = True
  try:
    if not _validate_ip_format(addr):
      ret =  False
    if ret:
      match = re.search('([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)', addr)
      if match:
        ip_tup = match.groups()
        for i in range(4):
          n = int(ip_tup[i])
          if n < 1 or n > 255:
            ret = False
            break
      else:
        ret = False
  except Exception, e:
    return False, "Error validating IP address : %s"%str(e)
  else:
    return ret, None

def validate_hostname(hostname):
  ret = True
  try :
    if len(hostname) > 255:
      ret = False
    if ret:
      if hostname.endswith("."): # A single trailing dot is legal
        hostname = hostname[:-1] # strip exactly one dot from the right, if present
      disallowed = re.compile("[^A-Z\d-]", re.IGNORECASE)
      ret = all( # Split by labels and verify individually
        (label and len(label) <= 63 # length is within proper range
         and not label.startswith("-") and not label.endswith("-") # no bordering hyphens
         and not disallowed.search(label)) # contains only legal characters
        for label in hostname.split("."))
  except Exception, e:
    return False, "Error validating hostname: %s"%str(e)
  else:
    return ret, None

def validate_ip_or_hostname(addr):
  try:
    ret = False
    ok, err = _validate_ip_format(addr)
    if err:
      raise Exception('Error validating address : %s'%err)
    if ok:
      ok, err = validate_ip(addr)
      if err:
        raise Exception('Error validating IP address : %s'%err)
      ret = ok
    else:
      ok, err = validate_hostname(addr)
      if err:
        raise Exception('Error validating hostname : %s'%err)
      ret = ok
  except Exception, e:
    return False, "Error validating IP/hostname: %s"%str(e)
  else:
    return ret, None

def get_subnet_in_cidr_format(ip, subnet):
  #Given an IP and a subnet (as in 255.255..) string, returns the subnet info in CIDR format (as in 192.168.1.0/24)

  network_addr = None
  try:
    ipmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", ip)
    nmmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", subnet)
    nms = ""
    network_addr = ""
    if ipmatch and nmmatch:
      ipl = ipmatch.groups()
      nml = nmmatch.groups()
      i=0
      while i < 4:
        binip =  bin(int(ipl[i]))
        #print binip
        binnm =  bin(int(nml[i]))
        nms += binnm[2:]
        #print binnm
        #print bin(int(ipl[i]) & int(nml[i]))
        network_addr += "%d"%(int(ipl[i]) & int(nml[i]))
        network_addr += '.'
        i+=1
  
    network_addr = network_addr[:(len(network_addr)-1)]
    count = 0
    #print nms
    for a in nms:
      if a == '1':
        count += 1
      else:
        break
    network_addr += '/%d'%count
  except Exception, e:
    return None, "Error getting CIDR subnet : %s"%str(e)
  else:
    return network_addr, None

def can_connect(hostname, port, timeout=0.05):
  #Check connectivity to a given hostname/port combo

  connected = False
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)

    connected = True if s.connect_ex((hostname,port)) == 0 else False

  except Exception, e:
    return False, "Error checking connectivity: %s"%str(e)
  else:
    return connected, None


'''

  NIC BONDING FUNCTIONS

'''
def remove_bond(bond_name):
  modified_file_list = []
  try:
    if not bond_name:
      raise Exception('No bond name provided')

    bm, err = get_bonding_masters()
    if err:
      raise Exception(err)

    #print bm
    if not bm or bond_name not in bm:
      raise Exception('Specified bond does not exist : %s'%err)

    bid, err = get_bonding_info_all()
    if err:
      raise Exception(err)
    if not bid:
      raise Exception('Specified bond configuration does not exist')

    ret, rc = command.execute_with_rc('ifconfig %s down'%bond_name)
    if rc != 0:
      err = ''
      tl = command.get_output_list(ret)
      if tl:
        err = ','.join(tl)
      tl = command.get_error_list(ret)
      if tl:
        err = err + ','.join(tl)
      raise Exception("Error shutting down network bond: %s"%err)

    shutil.copyfile('/etc/modprobe.d/bonding.conf', '/etc/modprobe.d/bonding.conf.bak')
    with open('/etc/modprobe.d/bonding.conf', 'w') as f:
      if 'by_master' in bid and bid['by_master']:
        for bn, binfo in bid['by_master'].items():
          if bn == bond_name:
            continue
          f.write('alias %s bonding\n'%bn)
          f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bn, binfo['mode_num']))
    modified_file_list.append('/etc/modprobe.d/bonding.conf')
    for slave in bid['by_master'][bond_name]['slaves']:
      shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s'%slave, '/etc/sysconfig/network-scripts/ifcfg-%s.bak'%slave)
      with open('/etc/sysconfig/network-scripts/ifcfg-%s'%slave, 'w') as f:
        f.write('DEVICE=%s\n'%slave)
        f.write('USERCTL=no\n')
        f.write('ONBOOT=yes\n')
        f.write('NM_CONTROLLED=yes\n')
        f.write('SLAVE=no\n')
        f.write('BOOTPROTO=none\n')
      modified_file_list.append('/etc/sysconfig/network-scripts/ifcfg-%s'%slave)
    shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s'%bond_name, '/etc/sysconfig/network-scripts/ifcfg-%s.bak'%bond_name)
    os.remove('/etc/sysconfig/network-scripts/ifcfg-%s'%bond_name)
    modified_file_list.append('/etc/sysconfig/network-scripts/ifcfg-%s'%bond_name)

    os.system('echo \"-%s\" > /sys/class/net/bonding_masters'%bond_name)
    ret, err = restart_networking()
    if not ret:
      if err:
        raise Exception(err)
      else:
        raise Exception("Error restarting networking services")
    #Now clean up all backed up files
    os.remove('/etc/modprobe.d/bonding.conf.bak')
    os.remove('/etc/sysconfig/network-scripts/ifcfg-%s.bak'%bond_name)
    filelist=glob.glob('/etc/sysconfig/network-scripts/ifcfg-*.bak')
    for file in filelist:
      os.remove(file) 
    
  except Exception, e:
    if modified_file_list:
      for file in modified_file_list:
        shutil.move('%s.bak'%file, file)
    return False, 'Error removing bond : %s'%str(e)
  else:
    return True, None
def create_bond(bond_name, slaves, mode, bootproto = None, addr_info = None):
  modified_file_list = []
  try:
    if not slaves:
      raise Exception('No slave interfaces provided')
    if not bond_name:
      raise Exception('No bond name provided')
    if not mode or mode not in [4,6]:
      raise Exception('Specified mode not supported')

    bm, err = get_bonding_masters()
    if err:
      raise Exception(err)
    if bm and bond_name in bm:
      raise Exception('A bond of the name already exists')

    bid, err = get_bonding_info_all()
    if err:
      raise Exception(err)
    if bid:
      for slave in slaves:
        if slave in bid['by_slave']:
          raise Exception('Interface %s is already part of another bond'%slave)

    #All ok now so go ahead
    shutil.copyfile('/etc/modprobe.d/bonding.conf', '/etc/modprobe.d/bonding.conf.bak')
    #print 'a1'
    with open('/etc/modprobe.d/bonding.conf', 'w') as f:
      if 'by_master' in bid and bid['by_master']:
        for bn, binfo in bid['by_master'].items():
          #print binfo
          f.write('alias %s bonding\n'%bn)
          f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bn, int(binfo['mode_num'])))
      f.write('alias %s bonding\n'%bond_name)
      f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bond_name, mode))
    #print 'a2'
      
    modified_file_list.append('/etc/modprobe.d/bonding.conf')

    for slave in slaves:
      shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s'%slave, '/etc/sysconfig/network-scripts/ifcfg-%s.bak'%slave)
      with open('/etc/sysconfig/network-scripts/ifcfg-%s'%slave, 'w') as f:
        f.write('DEVICE=%s\n'%slave)
        f.write('USERCTL=no\n')
        f.write('ONBOOT=yes\n')
        f.write('NM_CONTROLLED=yes\n')
        f.write('MASTER=%s\n'%bond_name)
        f.write('SLAVE=yes\n')
        f.write('BOOTPROTO=none\n')
      modified_file_list.append('/etc/sysconfig/network-scripts/ifcfg-%s'%slave)
    if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s'%bond_name):
      shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s'%bond_name, '/etc/sysconfig/network-scripts/ifcfg-%s.bak'%bond_name)
    with open('/etc/sysconfig/network-scripts/ifcfg-%s'%bond_name, 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('DEVICE=%s\n'%bond_name)
      if not bootproto:
        f.write('BOOTPROTO=none\n')
      elif bootproto == 'dhcp':
        f.write('BOOTPROTO=dhcp\n')
      elif bootproto == 'static':
        f.write('IPADDR=%s\n'%addr_info[0])
        f.write('NETMASK=%s\n'%addr_info[1])
        if len(addr_info) > 2:
          f.write('GATEWAY=%s\n'%addr_info[2])
        f.write('BOOTPROTO=none\n')
      f.write('MTU=1500\n')
      f.write('NM_CONTROLLED=yes\n')
      f.write('ONBOOT=yes\n')
      f.write('USERCTL=no\n')
    modified_file_list.append('/etc/sysconfig/network-scripts/ifcfg-%s'%bond_name)

    ret, err = restart_networking()
    if not ret:
      if err:
        raise Exception(err)
      else:
        raise Exception("Error restarting networking services")
      
  except Exception, e:
    if modified_file_list:
      for file in modified_file_list:
        shutil.move('%s.bak'%file, file)
    return False, 'Error configuring bond : %s'%str(e)
  else:
    return True, None

def get_bonding_type(bondname):

  mode = -1
  try:
    with open('/etc/modprobe.d/bonding.conf', 'r') as f:
      for line in f:
        if bondname not in line:
          continue
        fields = line.strip().split()
        if fields and fields[0].lower() == 'options':
          r = re.match('[\s\S]*mode=([0-9])', line.strip())
          if r:
            mode_str = r.groups()[0]
            if mode_str:
              mode = int(mode_str)
  except Exception, e:
    #print e
    return mode, 'Error retrieving bonding type : %s'%str(e)
  else:
    return mode, None

def set_bonding_type(bondname, bonding_type):
  if bonding_type not in [4, 6]:
    print "Unsupported bonding type : %d"%bonding_type
    return -1
  try:
    with open('/etc/modprobe.d/bonding.conf', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('alias %s bonding\n'%bondname)
      f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bondname, bonding_type))
      f.flush()
    f.close()
  except Exception, e:
    #print e
    return -1
  else:    
    return 0

def set_bond_ip_info(d):
  #Only sets the bonding for bond0 to prevent other things from changing
  try:
    with open('/etc/sysconfig/network-scripts/ifcfg-bond0', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('DEVICE=bond0\n')
      f.write('IPADDR=%s\n'%d['ip'])
      f.write('NETMASK=%s\n'%d['netmask'])
      f.write('GATEWAY=%s\n'%d['default_gateway'])
      f.write('MTU=%s\n'%d['mtu'])
      f.write('NM_CONTROLLED=no\n')
      f.write('BOOTPROTO=none\n')
      f.write('ONBOOT=yes\n')
      f.write('USERCTL=no\n')
      f.flush()
    f.close()
    return 0
  except Exception, e:
    return -1

def get_bonding_masters():
  masters = []
  try:
    if os.path.isfile('/sys/class/net/bonding_masters'):
      with open('/sys/class/net/bonding_masters', 'r') as f:
        lines = f.readlines()
        if lines:
          for line in lines:
            masters += (line.strip().split())
  except Exception, e:
    return 'unknown', 'Error retrieving bonding masters: %s'%str(e)
  else:
    return masters, None

def get_bonding_info(bond_name, bonding_masters = None):
  return_dict = None
  try:
    if not bond_name:
      raise Exception('No bond name specified')
    #print bond_name
    if not bonding_masters:
      bonding_masters, err =  get_bonding_masters()
      if err:
        raise Exception(err)
    #print '2'
    if bonding_masters and bond_name in bonding_masters:
      return_dict = {}
      #print '3'
      with open('/sys/class/net/%s/mtu'%bond_name, 'r') as f:
        mtu = int(f.readline().strip())
        return_dict['mtu'] = mtu
      #print '4'
      '''
      with open('/sys/class/net/%s/duplex'%bond_name, 'r') as f:
        duplex = f.readline()
        if duplex:
          duplex = duplex.strip()
        return_dict['duplex'] = duplex
      #print '5'
      with open('/sys/class/net/%s/speed'%bond_name, 'r') as f:
        speed = f.readline().strip()
        return_dict['speed'] = speed
      #print '6'
      with open('/sys/class/net/%s/bonding/active_slave'%bond_name, 'r') as f:
        active_slave = f.readline().strip()
        return_dict['active_slave'] = active_slave
      ##print '7'
      '''
      with open('/sys/class/net/%s/bonding/slaves'%bond_name, 'r') as f:
        slaves_str = f.readline().strip()
        slaves = slaves_str.split()
        return_dict['slaves'] = slaves
      #print '8'
      with open('/sys/class/net/%s/bonding/mii_status'%bond_name, 'r') as f:
        mii_status = f.readline().strip()
        return_dict['mii_status'] = mii_status
      #print '9'
      with open('/sys/class/net/%s/bonding/mode'%bond_name, 'r') as f:
        mode_str = f.readline().strip()
        mode = mode_str.split()
        return_dict['mode_str'] = mode[0]
        return_dict['mode_num'] = mode[1]
      #print '10'
      with open('/sys/class/net/%s/bonding/downdelay'%bond_name, 'r') as f:
        downdelay = int(f.readline().strip())
        return_dict['downdelay'] = downdelay
      #print '11'
      with open('/sys/class/net/%s/bonding/updelay'%bond_name, 'r') as f:
        updelay = int(f.readline().strip())
        return_dict['updelay'] = updelay
      #print '12'
  except Exception, e:
    return 'unknown', 'Error retrieving bonding information: %s'%str(e)
  else:
    return return_dict, None

def get_bonding_info_all():
  return_dict = {}
  try:
    masters, err = get_bonding_masters()
    if err:
      raise Exception(err)
    return_dict['by_master'] = {}
    return_dict['by_slave'] = {}
    if masters:
      for master in masters:
        bond, err = get_bonding_info(master, masters)
        if err:
          raise Exception(err)
        return_dict['by_master'][master] = bond
        for slave in bond['slaves']:
          if slave not in return_dict['by_slave']:
            return_dict['by_slave'][slave] = master
        
        
  except Exception, e:
    return None, 'Error retrieving all bonding information: %s'%str(e)
  else:
    return return_dict, None
'''

  FUNCTIONS TO SET  AND GET VARIOUS INFO FOR AN INTERFACE

'''

def get_interfaces():
  if_dict = {}
  try:
    bonding_masters = None
    bonding_slaves = None
    il = netifaces.interfaces()
    gwd, err = get_all_gateways()
    bm, err = get_bonding_info_all()
    if err:
      raise Exception(err)
    if bm:
      bonding_slaves = bm['by_slave']
      bonding_masters = bm['by_master']
    for i in il:
      bootproto, err = get_interface_bootproto(i)
      gateway, err = get_interface_default_gateway(i)
      #print gateway, err
      addresses = netifaces.ifaddresses(i)
      d = {}
      d['gateways'] = []
      if gateway:
        d['gateways'].append((gateway, i, True))
      d['addresses'] = {}
      d['bootproto'] = bootproto
      if bm and i in bm:
        d['bonding_master'] = True
      if bonding_masters and i in bonding_masters:
        d['bonding_master'] = True
      if bonding_slaves and i in bonding_slaves:
        d['slave_to'] = bonding_slaves[i]
      d['carrier_status'], err = get_interface_carrier_status(i)
      d['up_status'], err = get_interface_up_status(i)
      d['speed'], err = get_interface_speed(i)
      d['mtu'], err = get_interface_mtu(i)
      #d['enabled_status'], err = get_interface_enabled_status(i)
      
      if netifaces.AF_INET in addresses:
        d['addresses']['AF_INET'] = addresses[netifaces.AF_INET]
        '''
        if gwd and 'AF_INET' in gwd:
          for gw in gwd['AF_INET']:
            if gw[1] == i:
              d['gateways'].append(gw)
        '''
      if netifaces.AF_INET6 in addresses:
        d['addresses']['AF_INET6'] = addresses[netifaces.AF_INET6]
        '''
        if gwd and 'AF_INET6' in gwd:
          for gw in gwd['AF_INET6']:
            if gw[1] == i:
              d['gateways'].append(gw)
        '''
      if netifaces.AF_LINK in addresses:
        d['addresses']['AF_LINK'] = addresses[netifaces.AF_LINK]
        '''
        if gwd and 'AF_LINK' in gwd:
          for gw in gwd['AF_LINK']:
            if gw[1] == i:
              d['gateways'].append(gw)
        '''
      if_dict[i] = d
  except Exception, e:
    return None, 'Error retrieving interfaces : %s'%str(e)
  else:
    return if_dict, None

def get_ip_info(ifname):
  ip_info = {}
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    ip_info["ipaddr"] = socket.inet_ntoa(fcntl.ioctl( s.fileno(), 0x8915,  struct.pack('256s', ifname[:15]))[20:24])
    ip_info["netmask"] = socket.inet_ntoa(fcntl.ioctl(s.fileno(), 35099, struct.pack('256s', ifname))[20:24])
    """Read the default gateway directly from /proc."""
    with open("/proc/net/route") as fh:
      for line in fh:
        fields = line.strip().split()
        if fields[1] != '00000000' or not int(fields[3], 16) & 2:
          continue
        else:
          ip_info["default_gateway"] = socket.inet_ntoa(struct.pack("<L", int(fields[2], 16)))
          break
  except Exception, e:
    return None, 'Error retrieving IP info : %s'%str(e)
  return ip_info, None

  
def get_interface_carrier_status(if_name):
  status = 'unknown'
  try:
    if os.path.isfile('/sys/class/net/%s/carrier'%if_name):
      with open('/sys/class/net/%s/carrier'%if_name, 'r') as f:
        line = f.readline()
        status = int(line.strip())
        if status == 1:
          status = 'connected'
        elif status == 0:
          status = 'disconnected'
  except Exception, e:
    return 'unknown', 'Error retrieving interface carrier status: %s'%str(e)
  else:
    return status, None

def get_interface_speed(if_name):
  speed = 'unknown'
  try:
    if os.path.isfile('/sys/class/net/%s/speed'%if_name):
      with open('/sys/class/net/%s/speed'%if_name, 'r') as f:
        line = f.readline()
        speed = int(line.strip())
  except Exception, e:
    return 'unknown', 'Error retrieving interface speed: %s'%str(e)
  else:
    return speed, None

def get_interface_mtu(if_name):
  mtu = 'unknown'
  try:
    if os.path.isfile('/sys/class/net/%s/mtu'%if_name):
      with open('/sys/class/net/%s/mtu'%if_name, 'r') as f:
        line = f.readline()
        mtu = int(line.strip())
  except Exception, e:
    return 'unknown', 'Error retrieving interface mtu: %s'%str(e)
  else:
    return mtu, None

def get_interface_up_status(if_name):
  status = 'unknown'
  try:
    if os.path.isfile('/sys/class/net/%s/operstate'%if_name):
      with open('/sys/class/net/%s/operstate'%if_name, 'r') as f:
        line = f.readline()
        status = line.strip()
  except Exception, e:
    return None, 'Error retrieving interfaces status : %s'%str(e)
  else:
    return status, None

def get_interface_enabled_status(if_name):
  status = 'unknown'
  try:
    if os.path.isfile('/sys/class/net/%s/device/enable'%if_name):
      with open('/sys/class/net/%s/device/enable'%if_name, 'r') as f:
        line = f.readline()
        st = int(line.strip())
        if st == 1:
          status = 'enabled'
        elif st == 0:
          status = 'disabled'
  except Exception, e:
    return 'unknown', 'Error retrieving interface enabled status: %s'%str(e)
  else:
    return status, None

def set_interface_state(if_name, state):
  try:
    if (not if_name) or (not state):
      raise Exception('Interface name or state not specified')

    if state not in ['up', 'down']:
      raise Exception('Unsupported state in state change request')

    cmd = 'ifconfig %s %s'%(if_name, state)
    #print cmd
    ret, rc = command.execute_with_rc(cmd)
    if rc == 0:
      lines = command.get_output_list(ret)
    else:
      err = ''
      tl = command.get_output_list(ret)
      if tl:
        err = ','.join(tl)
      tl = command.get_error_list(ret)
      if tl:
        err = err + ','.join(tl)
      raise Exception(err)
  except Exception, e:
    return False, 'Error setting interface state: %s '%str(e)
  else:
    return True, None

def get_interface_bootproto(if_name):
  bootproto = 'none'
  try:
    with open('/etc/sysconfig/network-scripts/ifcfg-%s'%if_name, 'r') as f:
      lines = f.readlines()
      for line in lines:
        if 'bootproto' in line.strip().lower():
          pos = line.strip().find('=')
          if pos != -1:
            bootproto = line[pos+1:].strip()
  except Exception, e:
    return None, str(e)
  else:
    return bootproto, None

def get_interface_default_gateway(if_name):
  gateway = None
  try:
    with open('/etc/sysconfig/network-scripts/ifcfg-%s'%if_name, 'r') as f:
      lines = f.readlines()
      for line in lines:
        if 'gateway' in line.strip().lower():
          pos = line.strip().find('=')
          if pos != -1:
            gateway = line[pos+1:].strip()
  except Exception, e:
    return None, str(e)
  else:
    return gateway, None
      
def set_interface_ip_info(if_name, d):
  #Only sets the bonding for bond0 to prevent other things from changing
  try:
    with open('/etc/sysconfig/network-scripts/ifcfg-%s'%if_name, 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('DEVICE=%s\n'%if_name)
      if d['addr_type'] == 'static':
        f.write('IPADDR=%s\n'%d['ip'])
        f.write('NETMASK=%s\n'%d['netmask'])
        f.write('BOOTPROTO=static\n')
      else:
        f.write('BOOTPROTO=dhcp\n')
      if 'default_gateway' in d and d['default_gateway']:
        f.write('GATEWAY=%s\n'%d['default_gateway'])
      if 'mtu' in d:
        f.write('MTU=%s\n'%d['mtu'])
      else:
        f.write('MTU=1500\n')
      f.write('NM_CONTROLLED=yes\n')
      f.write('ONBOOT=yes\n')
      f.write('USERCTL=no\n')
      f.flush()
    f.close()
    return True, None
  except Exception, e:
    return False, 'Error setting IP information : %s'%str(e)


'''

  HOSTNAME/DOMAIN GET AND SET FUNCTIONS

'''

def set_hostname(hostname, domain_name):
  try:
    old_hostname = socket.gethostname()
    with open('/etc/sysconfig/network', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('NETWORKING=yes\n')
      f.write('HOSTNAME=%s\n'%hostname)
      f.flush()
    f.close()
    r, rc = command.execute_with_rc('hostname %s'%hostname)
    if rc == 0:
      if os.path.isfile('/etc/salt/minion_id'):
        os.remove('/etc/salt/minion_id')
    else:
      raise Exception("Error setting hostname. Return code %d"%rc)
    with open('/tmp/integralstor_newhosts', 'w') as f1:
      if domain_name:
        f1.write('127.0.0.1 localhost %s %s.%s\n'%(hostname, hostname, domain_name))
      else:
        f1.write('127.0.0.1 localhost %s\n'%hostname)
    shutil.move('/tmp/integralstor_newhosts', '/etc/hosts')
  except Exception, e:
    return False, 'Error setting hostname : %s'%str(e)
  else:
    return True, None

def set_domain_name(domain_name):
  try:
    with open('/etc/resolv.conf', 'r') as rf:
      lines = rf.readlines()
    with open('/tmp/integralstor_newresolv', 'w') as wf:
      if domain_name:
        wf.write('domain %s\n'%domain_name)
      for line in lines:
        res = re.match('domain[\s]+([\S\w]+)', line.strip()) 
        if res:
          continue
        wf.write('%s\n'%line.strip())
      wf.flush()
      wf.close()
    shutil.move('/tmp/integralstor_newresolv', '/etc/resolv.conf')
  except Exception, e:
    return False, 'Error setting domain name : %s'%str(e)
  else:
    return True, None

def get_domain_name():
  dn = None
  try:
    hostname = socket.gethostname()
    if '.' in hostname:
      dn = hostname[hostname.find('.')+1:]
    elif os.path.isfile('/etc/resolv.conf'):
      with open('/etc/resolv.conf', 'r') as f:
        lines = f.readlines()
        for line in lines:
          if line.strip()[0] == '#':
            continue
          res = re.match('domain[\s]+([\S\w]+)', line.strip()) 
          if res:
            gr = res.groups()
            dn = gr[0]
            break
  except Exception, e:
    return None, 'Error retrieving domain name : %s'%str(e)
  else:
    return dn, None

'''

  SET AND GET NAME SERVERS

'''
def get_name_servers():
  name_server_list = []
  try :
    with open('/etc/resolv.conf', 'r') as f:
      for line in f:
        if line.startswith('#'):
          continue
        fields = line.strip().split()
        if fields and fields[0].lower() == 'nameserver':
          i = 1
          while i < len(fields):
            name_server_list.append(fields[i])
            i += 1
  except Exception, e:
    return None, 'Error retrieving name servers : %s'%str(e)
  else:
    return name_server_list, None

def set_name_servers(ns_list):
  try:
    dn, err = get_domain_name()
    if err:
      raise Exception(err)
    with open('/etc/resolv.conf', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      if dn:
        f.write('domain %s\n'%dn)
      for n in ns_list:
        if n:
          f.write('nameserver %s\n'%n)
      f.flush()
    f.close()
  except Exception, e:
    return False, 'Error setting name servers : %s'%str(e)
  else:
    return True, None

def jumbo_frames_enabled(ifname):
  jumbo_frames = False
  try :
    with open('/etc/sysconfig/network-scripts/ifcfg-%s'%ifname, 'r') as f:
      for line in f:
        if line.startswith('#'):
          continue
        fields = line.strip().split('=')
        if fields[0].lower() == 'mtu':
          if len(fields) == 2:
            if int(fields[1]) == 9000:
              jumbo_frames = True
            else:
              jumbo_frames = False
  except Exception, e:
    return None
  else:
    return jumbo_frames

'''

  CHANGE THE CONFIGURATION FOR A NAMED DNS SERVER

'''
def generate_default_primary_named_conf(primary_ip, primary_netmask, secondary_ip, generate_forwarders = False, forwarder_ip = None, generate_zone_file = True):
  rc = 0
  try :
    primary_cidr_netmask = get_subnet_in_cidr_format(primary_ip, primary_netmask)

    with open('/etc/named.conf', 'w') as f:
      f.write('// Generated by the IntegralStor script\n')
      f.write("options {\n")
      f.write(" listen-on port 53 { any; };\n")
      f.write(" listen-on-v6 port 53 { ::1; };\n")
      f.write(' directory 	"/var/named";\n')
      f.write(' dump-file 	"/var/named/data/cache_dump.db";\n')
      f.write(' statistics-file "/var/named/data/named_stats.txt";\n')
      f.write(' memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
      f.write(" allow-query     { localhost; any; };\n")
      f.write(" allow-transfer  { localhost; %s; };\n"%secondary_ip)
      if generate_forwarders:
        f.write(" forwarders    { %s; };\n"%forwarder_ip)
        f.write(" recursion yes;\n")
      else:
        f.write(" recursion no;\n")
      f.write("};\n")

      f.write("logging {\n")
      f.write(" channel default_debug {\n")
      f.write('   file "data/named.run";\n')
      f.write("   severity dynamic;\n")
      f.write(" };\n")
      f.write("};\n")


      f.write('zone "." IN {\n')
      f.write(" type hint;\n")
      f.write(' file "named.ca";\n')
      f.write("};\n")

      f.write('zone "fractalio.lan" IN {\n')
      f.write(" type master;\n")
      f.write(' file "fractalio.for";\n')
      f.write(" allow-update { localhost; %s; };\n"%primary_cidr_netmask)
      f.write("};\n")

      f.write('include "/etc/named.rfc1912.zones";\n')
      f.flush()
    f.close()
    if generate_zone_file:
      rc = generate_default_zone_file(primary_ip, secondary_ip)
      if rc != 0:
        raise Exception ('Error generating the default zone file')
    r, rc = command.execute_with_rc('service named reload')
    if rc != 0:
      print "Error restarting the DNS server"
  except Exception, e:
    print "Error generating the master DNS configuration file : %s"%e
    return -1
  else:
    return rc

def generate_default_zone_file(primary_ip, secondary_ip):
  try:
    with open('/var/named/fractalio.for', 'w') as f1:
      f1.write('$ORIGIN .\n')
      f1.write('$TTL 86400    ; 1 day\n')
      f1.write('fractalio.lan        IN SOA    fractalio-pri.fractalio.lan. root.fractalio.lan. (\n')
      f1.write('                                2011071026 ; serial\n')
      f1.write('                                3600       ; refresh (1 hour)\n')
      f1.write('                                1800       ; retry (30 minutes)\n')
      f1.write('                                604800     ; expire (1 week)\n')
      f1.write('                                86400      ; minimum (1 day)\n')
      f1.write('                )\n')
      f1.write('            NS    fractalio-pri.fractalio.lan.\n')
      f1.write('            NS    fractalio-sec.fractalio.lan.\n')
      f1.write('            PTR    fractalio.lan.\n')
      f1.write('$ORIGIN fractalio.lan.\n')
      f1.write('fractalio-pri          A    %s\n'%primary_ip)
      f1.write('fractalio-sec        A    %s\n'%secondary_ip)
      f1.flush()
    f1.close()
  except Exception, e:
    print "Error generating zone file : %s"%e
    return -1
  else:
    return 0

def generate_default_secondary_named_conf(primary_ip, secondary_netmask, secondary_ip, generate_forwarders = False, forwarder_ip = None):
  rc = 0
  try :
    secondary_cidr_netmask = get_subnet_in_cidr_format(primary_ip, secondary_netmask)

    with open('/etc/named.conf', 'w') as f:
      f.write('// Generated by the IntegralStor script\n')
      f.write('options {\n')
      f.write('  listen-on port 53 { any; };\n')
      f.write('  listen-on-v6 port 53 { ::1; };\n')
      f.write('  directory 	"/var/named";\n')
      f.write('  dump-file 	"/var/named/data/cache_dump.db";\n')
      f.write('  statistics-file "/var/named/data/named_stats.txt";\n')
      f.write('  memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
      f.write('  allow-query     { localhost; %s; };\n'%secondary_cidr_netmask)
      if generate_forwarders:
        f.write("   forwarders    { %s; };\n"%forwarder_ip)
        f.write('  recursion yes;\n')
      else:
        f.write('  recursion no;\n')
      f.write('};\n')

      f.write('logging {\n')
      f.write('  channel default_debug {\n')
      f.write('    file "data/named.run";\n')
      f.write('    severity dynamic;\n')
      f.write('  };\n')
      f.write('};\n')


      f.write('zone "." IN {\n')
      f.write('  type hint;\n')
      f.write('  file "named.ca";\n')
      f.write('};\n')


      f.write('zone "fractalio.lan" IN {\n')
      f.write('  type slave;\n')
      f.write('  file "slaves/fractalio.for";\n')
      f.write('  masters { %s; };\n'%primary_ip)
      f.write('};\n')
      f.write('include "/etc/named.rfc1912.zones";\n')
      f.flush()
    f.close()
    r, rc = command.execute_with_rc('service named restart')
    if rc != 0:
      print "Error restarting the DNS server"
  except Exception, e:
    print "Error generating the DNS slave configuration file : %s"%e
    return -1
  else:
    return rc



'''

  GATEWAY RELATED FUNCTIONS

'''

def get_default_gateways():
  gw_dict = {}
  try:
    gd = netifaces.gateways()
    if gd and 'default' in gd:
      if netifaces.AF_INET in gd['default']:
        gw_dict['AF_INET'] = gd['default'][netifaces.AF_INET]
      if netifaces.AF_INET6 in gd['default']:
        gw_dict['AF_INET6'] = gd['default'][netifaces.AF_INET6]
      if netifaces.AF_LINK in gd['default']:
        gw_dict['AF_LINK'] = gd['default'][netifaces.AF_LINK]

      
  except Exception, e:
    return None, 'Error retrieving default gateways : %s'%str(e)
  else:
    return gw_dict, None

def get_all_gateways():
  gw_dict = {}
  try:
    gd = netifaces.gateways()
    for family, gw_info in gd.items():
      if family == 'default':
        continue
      if family == netifaces.AF_INET:
        gw_dict['AF_INET'] = gw_info
      elif family == netifaces.AF_INET6:
        gw_dict['AF_INET6'] = gw_info
      elif family == netifaces.AF_LINK:
        gw_dict['AF_LINK'] = gw_info
      
  except Exception, e:
    return None, 'Error retrieving gateways : %s'%str(e)
  else:
    return gw_dict, None


def restart_networking():

  try:
    ret, rc = command.execute_with_rc('service network restart')
    if rc != 0:
      err = ''
      tl = command.get_output_list(ret)
      if tl:
        err = ','.join(tl)
      tl = command.get_error_list(ret)
      if tl:
        err = err + ','.join(tl)
      raise Exception(err)
  except Exception, e:
    return False, "Error restarting networking services : %s"%str(e)
  else:
    return True, None



if __name__ == "__main__":
  #print get_bonding_type('bond0')
  #print get_ip_info('bond0')
  #print get_name_servers()
  #set_hostname('primary1')
  #print set_bonding_type('bond0', 6)
  #print jumbo_frames_enabled('bond0')
  #print generate_default_primary_named_conf('10.1.1.4', '255.255.255.0', '10.1.1.5')
  #set_name_servers(['192.168.1.248', '192.168.1.249', None])
  #set_hostname('primary.fractalio.lan')
  #rc = change_hosts_file_entry('fractalio-pri', '10.1.1.20', 'fractalio-pri', '10.1.1.4')
  #print rc
  r, err = get_interfaces()
  #r, err = get_default_gateways()
  #r, err = get_all_gateways()
  #r, err = get_interface_carrier_status('eth0')
  #r, err = get_interface_up_status('eth0')
  #r, err = get_bonding_masters()
  #r, err = get_bonding_info('bond1')
  #r, err = get_bonding_info_all()
  #r, err = create_bond('bond1', ['eth0', 'eth1'], 6, False, ['192.168.1.246', '255.255.255.0', '192.168.1.7'])
  #r, err = remove_bond('bond0')
  #r, err = get_domain_name()
  pp = pprint.PrettyPrinter(indent=4)
  pp.pprint(r)
  print err
'''
def set_hosts_file_hostname_entry(old_hostname, new_hostname, new_ip):
  try:
    with open('/etc/hosts', 'r') as f:
      with open('/tmp/integralstor_newhosts', 'w') as f1:
        for line in f:
          if line.startswith('#'):
            continue
          if (old_hostname and old_hostname in line.strip()) or (old_ip and old_ip in line.strip()):
            continue
          else:
            f1.write('%s\n'%line.strip())
        f1.write('%s %s %s.fractalio.lan\n'%(new_ip, new_hostname, new_hostname))
    shutil.move('/tmp/integralstor_newhosts', '/etc/hosts')
  except Exception, e:
    return False, 'Error changing hosts file : %s'%str(e)
  else:
    return True, None
'''
