
from integralstor_common import command, db, common
def change_auth_method(security):

  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    cl = []
    cl.append(["update samba_global_common set security='%s' where id=1"%security])
    cl.append(["delete from samba_valid_users"])
    ret, err = db.execute_iud("%s/integral_view_config.db"%db_path, cl)
    if err:
      raise Exception(err)
  except Exception, e:
    return False, 'Error changing authentication method : %s'%str(e)
  else:
    return True, None

def load_auth_settings():
  d = None
  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    d, err = db.read_single_row("%s/integral_view_config.db"%db_path, "select * from samba_global_common where id=1")
    if err:
      raise Exception(err)
    if d and d["security"] == "ads":
      d1, err = db.read_single_row("%s/integral_view_config.db"%db_path, "select * from samba_global_ad where id=1")
      if err:
        raise Exception(err)
      if d1:
        d.update(d1)
  except Exception, e:
    return None, 'Error loading authentication settings : %s'%str(e)
  else:
    return d, None


def save_auth_settings(d):

  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    cmd = ["update samba_global_common set workgroup=?, netbios_name=?, security=?, include_homes_section=? where id = ?", (d["workgroup"], d["netbios_name"], d["security"], True, 1,)]
    cmd_list = []
    cmd_list.append(cmd)
    if d["security"] == "ads":
      d1, err = db.read_single_row("%s/integral_view_config.db"%db_path, "select * from samba_global_ad")
      if err:
        raise Exception(err)
      if d1:
        cmd = ["update samba_global_ad set realm=?, password_server=?, ad_schema_mode=?, id_map_min=?, id_map_max=?, password_server_ip=?  where id = ?", (d["realm"], d["password_server"], 'rfc2307', 16777216, 33554431, d["password_server_ip"], 1, )]
        cmd_list.append(cmd)
      else:
        cmd = ["insert into samba_global_ad (realm, password_server, ad_schema_mode, id_map_min, id_map_max, password_server_ip, id) values(?,?,?,?,?,?,?)", (d["realm"], d["password_server"], 'rfc2307', 16777216, 33554431, d["password_server_ip"], 1,)]
        cmd_list.append(cmd)
    #print cmd_list
    #Always try to create the fractalio_guest account for guest access - will fail if it exists so ok
    ret, err = db.execute_iud("%s/integral_view_config.db"%db_path, cmd_list)
    if err:
      raise Exception(err)
  except Exception, e:
    return False, 'Error saving authentication settings : %s'%str(e)
  else:
    return True, None


def delete_auth_settings():
  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    ret, err = db.execute_iud("%s/integral_view_config.db"%db_path, [["delete from samba_auth "]])
    if err:
      raise Exception(err)
  except Exception, e:
    return False, 'Error deleting authentication settings : %s'%str(e)
  else:
    return True, None

def load_shares_list():
  l = []
  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    l, err = db.read_multiple_rows("%s/integral_view_config.db"%db_path, 'select * from samba_shares')
    if err:
      raise Exception(err)
  except Exception, e:
    return None, 'Error loading CIFS shares list : %s'%str(e)
  else:
    return l, None

def get_shares_on_subpath(subpath):
  #Given a subpath, return all shares that have that path prefix. Used to find shares on a pool
  l = []
  try:
    if not subpath.startswith('/'):
      subpath = '/%s'%subpath
    if not subpath.endswith('/'):
      subpath += '/'
    share_list, err = load_shares_list()
    if err:
      raise Exception(err)
    if share_list:
      for share in share_list:
        share_path = share['path']
        if not share_path.endswith('/'):
          share_path += '/'
        if subpath in share_path:
          l.append(share)
  except Exception, e:
    return None, 'Error retrieving shares on subpath: %s'%str(e)
  else:
    return l, None

def load_share_info(mode, index):
  d = None
  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    query = None
    if mode == "by_id":
      query = "select * from samba_shares where share_id = %s"%index
    else:
      query = "select * from samba_shares where name = %s"%index
    d, err = db.read_single_row("%s/integral_view_config.db"%db_path, query)
    if err:
      raise Exception(err)

  except Exception, e:
    return None, 'Error loading CIFS share information : %s'%str(e)
  else:
    return d, None


def delete_share(share_id):

  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    cmd_list = []
    cmd_list.append(["delete from samba_shares where share_id=?", (share_id, )])
    cmd_list.append(["delete from samba_valid_users where share_id=?", (share_id, )])
    ret, err = db.execute_iud("%s/integral_view_config.db"%db_path, cmd_list)
    if err:
      raise Exception(err)
  except Exception, e:
    return False, 'Error deleting CIFS share : %s'%str(e)
  else:
    return True, None

def delete_all_shares():
  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    cmd_list = []
    cmd_list.append(["delete from samba_shares "])
    cmd_list.append(["delete from samba_valid_users "])
    ret, err = db.execute_iud("%s/integral_view_config.db"%db_path, cmd_list)
    if err:
      raise Exception(err)
  except Exception, e:
    return False, 'Error deleting all CIFS shares : %s'%str(e)
  else:
    return True, None

def save_share(share_id, name, comment, guest_ok, read_only, path, browseable, users, groups):

  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    cmd_list = []
    cmd_list.append(["update samba_shares set comment=?, read_only=?, guest_ok=?, browseable=? where share_id=?", (comment, read_only, guest_ok, browseable,share_id, )])
    cmd_list.append(["delete from samba_valid_users where share_id=?", (share_id, )])
    if not guest_ok:
      if users:
        for user in users:
          cmd_list.append(["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, False, user,)])
      if groups:
        for group in groups:
          cmd_list.append(["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, True, group,)])
    ret, err = db.execute_iud("%s/integral_view_config.db"%db_path, cmd_list)
    if err:
      raise Exception(err)

  except Exception, e:
    return False, 'Error saving CIFS share : %s'%str(e)
  else:
    return True, None


def create_share(name, comment, guest_ok, read_only, path, display_path, browseable, users, groups, vol):
  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    d, err = load_auth_settings()
    if err:
      raise Exception(err)
    if not d:
      raise Exception("Authentication settings not set. Please set authentication settings before creating shares.")
    shl, err = load_shares_list()
    if err:
      raise Exception(err)
    if shl:
      for sh in shl:
        if sh["name"] == name :
          raise Exception("A share with that name already exists")

    share_id, err = db.execute_iud("%s/integral_view_config.db"%db_path, [["insert into samba_shares (name, vol, path, display_path, comment, read_only, guest_ok, browseable, share_id) values (?,?, ?,?,?,?,?,?,NULL)", (name, vol, path, display_path, comment, read_only, guest_ok, browseable,)]])
    if err:
      raise Exception(err)
    cmd_list = []
    if not guest_ok:
      if users:
        for user in users:
          cmd_list.append(["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, False, user,)])
      if groups:
        for group in groups:
          cmd_list.append(["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, True, group,)])
    ret, err = db.execute_iud("%s/integral_view_config.db"%db_path, cmd_list)
    if err:
      raise Exception(err)

  except Exception, e:
    return False, 'Error creating CIFS share : %s'%str(e)
  else:
    return True, None

def load_valid_users_list(share_id):
  l = None
  try:
    db_path, err = common.get_db_path()
    if err:
      raise Exception(err)
    l, err = db.read_multiple_rows("%s/integral_view_config.db"%db_path, 'select * from samba_valid_users where share_id = %s'%share_id)
    if err:
      raise Exception(err)
  except Exception, e:
    return None, 'Error loading valid users list : %s'%str(e)
  else:
    return l, None

def _get_ad_users_or_groups(type):
  o = None
  try:
    d, err = load_auth_settings()
    if err:
      raise Exception(err)
    workgroup = d['workgroup']
    if type and type=="users":
      o, err = command.get_command_output('wbinfo -u --domain=%s'%workgroup)
      if err:
        raise Exception(err)
    elif type and type=="groups":
      o, err = command.get_command_output('wbinfo -g --domain=%s'%workgroup)
      if err:
        raise Exception(err)
    else:
      raise Exception("Unknown type specified.")
    #print '%s - '%type, o

  except Exception, e:
    return None, 'Error retrieving Active Directory Users/Groups : %s'%str(e)
  else:
    return o, None

def generate_share_header(f, share_name):
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("\n[%s]\n"%share_name)
  except Exception, e:
    return False, 'Error generating CIFS configuration file, shares header section : %s'%str(e)
  else:
    return True, None

def generate_common_share_body(f, workgroup, path, read_only, browseable, guest_ok, user_list, group_list, comment, auth_method):
  try:
    if not f:
      raise Exception('No file handle passed')
    if comment:
      f.write("  comment = %s\n"%comment)
    f.write("  path = %s\n"%path)
    f.write("  create mask = 0660\n")
    f.write("  kernel share modes = no\n")
    f.write("  directory mask = 0770\n")
    f.write("  force group = integralstor\n")
    if read_only:
      t = "yes"
    else:
      t = "no"
    f.write("  read only = %s\n"%t)
    if user_list or group_list:
      s = "  valid users = "
      for user in user_list:
        if auth_method and auth_method == "users":
          s += " %s "%(user)
        else:
          s += " %s+%s "%(workgroup, user)
      for group in group_list:
        if auth_method and auth_method == "users":
          s += " @%s "%(group)
        else:
          s += " @%s+%s "%(workgroup, group)
      s += "\n"
      f.write(s)

    if browseable:
      t = "yes"
    else:
      t = "no"
    f.write("  browseable = %s\n"%t)
    if guest_ok:
      f.write("  guest ok = yes\n")
      #f.write("  guest account = %s\n"%guest_account)
  except Exception, e:
    return False, 'Error generating CIFS configuration file, common share body section : %s'%str(e)
  else:
    return True, None

def generate_global_header(f):
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("; This file has been programatically generated by the IntegralStor system. Do not modify it manually!\n\n")
    f.write("[global]\n")
  except Exception, e:
    return False, 'Error generating CIFS configuration file, global header section : %s'%str(e)
  else:
    return True, None

def generate_common_global_section(f, d):
  print d
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("  log file = /var/log/smblog.vfs\n")
    #f.write("  log level=5\n")
    f.write("  log level=1 acls:3 locking:3\n")
    f.write("  oplocks=yes\n")
    f.write("  ea support=yes\n")
    f.write("  level2 oplocks=yes\n")
    f.write("  posix locking=no\n")
    f.write("  load printers = no\n")
    f.write("  map to guest = bad user\n")
    f.write("  idmap config *:backend = tdb\n")
    f.write("  workgroup = %s\n"%d["workgroup"].upper())
    #f.write("  netbios name = %s\n"%d["netbios_name"].upper())
    if d["security"] == "ads":
      f.write("  security = ADS\n")
      f.write("  preferred master = no\n")
      f.write("  encrypt passwords = yes\n")
      f.write("  winbind enum users  = yes\n")
      f.write("  winbind enum groups = yes\n")
      f.write("  winbind use default domain = yes\n")
      f.write("  winbind nested groups = yes\n")
      f.write("  winbind separator = +\n")
      f.write("  local master = no\n")
      f.write("  domain master = no\n")
      f.write("  wins proxy = no\n")
      f.write("  dns proxy = no\n")
      #f.write("  idmap config *:range = %d-%d \n"%(d["id_map_max"]+1, d["id_map_max"]+10001))
      f.write("  winbind nss info = rfc2307\n")
      f.write("  winbind trusted domains only = no\n")
      f.write("  winbind refresh tickets = yes\n")
      f.write("  map untrusted to domain = Yes\n")
      f.write("  realm = %s\n"%d["realm"].upper())
      f.write("  idmap config %s:default = yes\n"%d["workgroup"].upper())
      f.write("  idmap config %s:backend = ad\n"%d["workgroup"].upper())
      f.write("  idmap config %s:schema_mode = %s\n"%(d["workgroup"].upper(), d["ad_schema_mode"]))
      #f.write("  idmap config %s:range = %d-%d\n"%(d["workgroup"].upper(), d["id_map_min"], d["id_map_max"]))
      f.write("  idmap config %s:range = 16777216-33554431\n")
      f.write("  idmap config %s:base_rid = 0\n"%d["workgroup"].upper())
  except Exception, e:
    return False, 'Error generating CIFS configuration file, common global section : %s'%str(e)
  else:
    return True, None

def generate_krb5_conf():
  try:
    d, err = load_auth_settings()
    if err:
      raise Exception(err)
    krb5_conf_path, err = common.get_krb5_conf_path()
    if err:
      raise Exception(err)
    with open("%s/krb5.conf"%krb5_conf_path, "w") as f:
      f.write("; This file has been programatically generated by the IntegralStor system. Do not modify it manually!\n\n")
      f.write("[logging]\n")
      f.write("  default = FILE:/var/log/krb5libs.log\n")
      f.write("  kdc = FILE:/var/log/krb5kdc.log\n")
      f.write("  admin_server = FILE:/var/log/kadmind.log\n")
  
      f.write("\n[libdefaults]\n")
      f.write("  default_realm = %s\n"%d["realm"].upper())
      f.write("\n[realms]\n")
      f.write("    %s = {\n"%d["realm"].upper())
      f.write("    kdc = %s\n"%d["password_server"])
      f.write("    admin_server = %s\n"%d["password_server"])
      f.write("  }\n")
      f.write("\n[domain_realm]\n")
      f.write("  .%s = %s\n"%(d["realm"].lower(), d["realm"].upper()))
      f.write("  %s = %s\n"%(d["realm"].lower(), d["realm"].upper()))
  except Exception, e:
    return False, 'Error generating kerberos configuration : %s'%str(e)
  else:
    return True, None

def main():
  print get_shares_on_subpath('/fractalio/ds1')
if __name__ == '__main__':
  main()
