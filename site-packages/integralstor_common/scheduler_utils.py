from integralstor_common import common,db,command
from db import execute_iud,read_multiple_rows
from command import execute_with_rc
from crontab import CronTab
import re,time,datetime
"""
  function to create a cron job
  Parameters :
  0 Name of the cron job
  1 Minute 0-59
  2 Hour 0-23 (0 = midnight)
  3 Day 1-31
  4 Month 1-12
  5 Weekday 0-6 (0 = Sunday) 
  6 Command to be executed. do not pass >> logfile 2>&1. It will be autocreated with the cronjob name
  Notes :
  Time value passing : 
    */1 wont work. It will be auto resolved to *. This actually means every 1 minute. So * indicates every time (minute or hour)
    Passing a list of values should be in string format. " '2-4,56',*,*,*,* "
  Command value passing :
    Pass the command along with the log file you want. If no log file is mentioned, the a default log file with the comment id will be generated.

"""


def create_cron(cron_name,min="1",hour='*',day='*',dow='*',month='*',command=None,log_file=None):
  try:
    log_path, err = common.get_log_folder_path()
    if err:
      raise Exception(err)
    cron = CronTab(user='root')
    if log_file is None:
      log_file =  re.sub(" ","_",cron_name)
    command = command + " >> " +log_path+"/"+log_file+ ".log 2>&1"
    job  = cron.new(command=command,comment=cron_name)
    job.setall(min,hour,day,dow,month)
    if job.is_valid():
      job.enable()
      cron.write()
    else:
      raise Exception("Job Not Valid. Please recheck the job created")
  except Exception, e:
    return False, 'Error creating cron entry : %s'%str(e)
  else:
    return True, None


# Function to return all the user created cron
def list_all_cron():
  cron_list = []
  try:
    cron = CronTab(user='root')
    for job in cron:
      if job.comment:
        cron_list.append(job)
  except Exception, e:
    return None, 'Error listing all cron entries : %s'%str(e)
  else:
    return cron_list, None

# Function to find a specific cron by comment / cron_name
def find_cron(name):
  job = None
  try:
    cron = CronTab(user='root')
    job = cron.find_comment(name)
  except Exception,e:
    return None, "Error finding cron entry : %s"%str(e)
  else:
    return job,None

# Delete a cron, given a comment / cron_name 
def delete_cron_with_comment(name):
  try:
    cron = CronTab(user='root')
    cron.remove_all(comment=name)
    cron.write()
  except Exception, e:
    return False, "Error deleting cron entry : %s"%str(e)
  else:
    return True,None


def schedule_a_job(db_path,task_name,cmd_list,execute_time=None,retries=3):
  if not task_name or not cmd_list:
    return False, "Parameters not sufficient"
  else:
    try:
      if not execute_time:
        now = execute_time = int(time.time())
      else:
        now = int(time.time())
      cmd =  "insert into scheduler_tasks (task_name,create_time,initiate_time,status) VALUES ('%s','%d','%d','%s');"%(task_name,now,execute_time,"scheduled");
      row_id,err = execute_iud(db_path,[[cmd],],get_rowid=True)
      if row_id and not err:
        error = False
        for cmd in cmd_list:
          cmd =  "insert into scheduler_commands (command,task_ref_id,retries) values ('%s','%d','%d');"%(cmd,row_id,retries)
          status,err = execute_iud(db_path,[[cmd],],get_rowid=True)
          if err:
            error = True
            break
        if error:
          return False,err
        else:
          return True,None
      else:
        return False,err
    except Exception,e:
      return False,e 
"""
# Still to implement :
1. Select queires to pick errors also
2. retries to be implemented.
"""
def execute_scheduler(db_path):
  now = int(time.time())
  tasks = "select * from scheduler_tasks where status == 'scheduled' or status == 'pending' and initiate_time <= '%d';" %(now)
  try:
    completed = True
    # Iterate all the scheduled tasks
    for task in read_multiple_rows(db_path,tasks)[0]:
      commands = "select * from scheduler_commands where task_ref_id == '%d'"%task['task_id']
      # Iteriate all the commands realted to the task
      for query in read_multiple_rows(db_path,commands)[0]:
        retries = query['retries']
        command_id = query["command_id"]
        # Change the status to running from schdeuled
        status_update = "update scheduler_commands set status = 'running' where command_id = '%d'"%command_id
        status,err = execute_iud(db_path,[[status_update],],get_rowid=True)
        (out,ret),err = execute_with_rc(query["command"],True)
        return_code = ret
        if out[0]:
          output = ''.join(out[0])
        else:
          output = None
        if out[1]:
          error = ''.join(out[1])
        else:
          error = None
        if ret == 0:
          # This means the command was successful. So update to completed
          status_update = "update scheduler_commands set status = 'completed', return_code='%d', output='%s', errors='%s' where command_id = '%d';"%(return_code,output,error,command_id)
          status,err = execute_iud(db_path,[[status_update],],get_rowid=True)
        if ret != 0:
          # Error Oh! Error
          completed = False
          if retries > 0:
            status_update = 'update scheduler_commands set status = "error", return_code="%d", output="%s", errors="%s",retries="%d" where command_id = "%d";'%(return_code,output,error,retries-1,command_id)
          else:
            status_update = 'update scheduler_commands set status = "error", return_code="%d", output="%s", errors="%s",retries="%d" where command_id = "%d";'%(return_code,output,error,retries,command_id)
          execute,err = execute_iud(db_path,[[status_update],],get_rowid=True)
          continue
      if completed:
        status_update = "update scheduler_tasks set status = 'completed' where task_id = '%d'"%task['task_id']
        status,err = execute_iud(db_path,[[status_update],],get_rowid=True)
      else:
        if retries > 0:
          status_update = "update scheduler_tasks set status = 'pending' where task_id = '%d'"%task['task_id']
        else:
          status_update = "update scheduler_tasks set status = 'error' where task_id = '%d'"%task['task_id']

        status,err = execute_iud(db_path,[[status_update],],get_rowid=True)
    return True,None
  except Exception as e:
    return None,e

def get_background_jobs(db_path):
  yesterday = int((datetime.datetime.now() - datetime.timedelta(minutes=15)).strftime("%s"))
  now = int((datetime.datetime.now()).strftime("%s"))
  tasks = "select * from scheduler_tasks where initiate_time >= '%d' and initiate_time <= %d;" %(yesterday,now)
  return read_multiple_rows(db_path,tasks)[0]
  

def main():
  #print create_cron("ZFS Snap Testing",2,'*','*','*','*',command="/sbin/zfs snapshot pool1@$(date +'%F_%H-%M')")
  #print list_all_cron()
  #print delete_cron_with_comment("test spacing")
  #cron = None
  #cron =  find_cron("test")
  #for param in cron:
  #  print param.command
  db_path = "/opt/integralstor/integralstor_unicell/config/db/integral_view_config.db"
  clear_table = "delete from scheduler_commands;"
  status,err = execute_iud(db_path,[[clear_table],],get_rowid=True)
  clear_table = "delete from scheduler_tasks;"
  status,err = execute_iud(db_path,[[clear_table],],get_rowid=True)
  for count in xrange(10,20):
    jobname = "Test_%d"%count
    if count < 18:
      schedule_a_job(db_path,jobname,['echo','echo','pwd'])
    else:
      schedule_a_job(db_path,jobname,['echo','echo123','pwd123'])
  print execute_scheduler(db_path)
  print execute_scheduler(db_path)
  print execute_scheduler(db_path)
  print execute_scheduler(db_path)
  print get_background_jobs(db_path)

if __name__ == "__main__":
  main()
